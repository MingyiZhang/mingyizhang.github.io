[{"content":"To use Kotlin suspend function in Java, we need to convert it to a non-blocking function. The following code snippet shows how to do it.\nfun \u0026lt;T\u0026gt; suspendToFuture( executor: Executor, block: suspend () -\u0026gt; T, ): CompletableFuture\u0026lt;T\u0026gt; { val future = CompletableFuture\u0026lt;T\u0026gt;() val dispatcher = executor.asCoroutineDispatcher() CoroutineScope(dispatcher + SupervisorJob()).launch { try { future.complete(block()) } catch (e: Exception) { future.completeExceptionally(e) } } return future } Suppose we have a suspend function:\nsuspend fun add(x: Int, y: Int): Int { delay(1000) return x + y } We can wrap it in a non-blocking function:\nfun addAsync( x: Int, y: Int, executor: Executor ): CompletableFuture\u0026lt;Int\u0026gt; = suspendToFuture(executor) { add(x, y) } Then we can use it in Java:\nfinal var executor = Executors.newSingleThreadExecutor(); final var future = addAsync(1, 2, executor); future.thenAccept(System.out::println); ","permalink":"https://mingyizhang.dev/post/20230723_kotlin-suspend-to-non-blocking/","summary":"To use Kotlin suspend function in Java, we need to convert it to a non-blocking function. The following code snippet shows how to do it.\nfun \u0026lt;T\u0026gt; suspendToFuture( executor: Executor, block: suspend () -\u0026gt; T, ): CompletableFuture\u0026lt;T\u0026gt; { val future = CompletableFuture\u0026lt;T\u0026gt;() val dispatcher = executor.asCoroutineDispatcher() CoroutineScope(dispatcher + SupervisorJob()).launch { try { future.complete(block()) } catch (e: Exception) { future.completeExceptionally(e) } } return future } Suppose we have a suspend function:","title":"Use Kotlin suspend function in Java"}]